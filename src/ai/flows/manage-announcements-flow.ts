
'use server';
/**
 * @fileOverview Manages announcements for the platform, interacting with a MySQL database.
 *
 * - createAnnouncement - Creates a new announcement.
 * - getAnnouncements - Retrieves all announcements.
 * - updateAnnouncement - Updates an existing announcement.
 * - deleteAnnouncement - Deletes an announcement.
 * - AnnouncementSchema - Zod schema for an announcement.
 * - CreateAnnouncementInputSchema - Zod schema for creating an announcement.
 * - UpdateAnnouncementInputSchema - Zod schema for updating an announcement.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit/zod';
import mysql from 'mysql2/promise';
import type { UserRole as AppUserRole } from '@/types';

// TODO: Define your database connection details in .env file
// Example .env variables:
// DB_HOST=tu_host
// DB_USER=tu_usuario
// DB_PASSWORD=tu_contraseña
// DB_NAME=tu_base_de_datos

const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
};

// Create a connection pool
// TODO: Ensure this pool is managed correctly (e.g., closed on app shutdown if needed)
// For serverless environments, creating a connection per request might be more appropriate.
let pool: mysql.Pool | undefined;
try {
  if (dbConfig.host && dbConfig.user && dbConfig.database) {
    pool = mysql.createPool(dbConfig);
    console.log("MySQL connection pool created successfully.");
  } else {
    console.warn("MySQL DB configuration is incomplete. Flows will not connect to DB.");
  }
} catch (error) {
  console.error("Failed to create MySQL connection pool:", error);
}


async function getConnection() {
  if (!pool) {
    throw new Error('MySQL connection pool is not initialized. Check DB_CONFIG in .env and server logs.');
  }
  return pool.getConnection();
}


// Extended UserRole for 'Todos' in target audience
const targetAudienceRoleOptions = ['Administrador', 'Instructor', 'Personal', 'Todos'] as const;
export type TargetAudienceRoleFlow = (typeof targetAudienceRoleOptions)[number];


const UrgencyLevelOptions = ['Normal', 'Importante', 'Urgente', 'Crítico'] as const;
export type UrgencyLevelFlow = (typeof UrgencyLevelOptions)[number];

export const AnnouncementSchema = z.object({
  id: z.string().describe('Unique identifier for the announcement. Typically auto-generated by the database or a UUID.'),
  title: z.string().min(5).max(100).describe('Title of the announcement.'),
  content: z.string().min(10).describe('Main content of the announcement.'),
  urgency: z.enum(UrgencyLevelOptions).describe('Urgency level of the announcement.'),
  publicationDate: z.string().datetime().describe('Date and time when the announcement is published. ISO 8601 format.'),
  expirationDate: z.string().datetime().nullish().describe('Optional date and time when the announcement expires. ISO 8601 format.'),
  author: z.string().describe('Author of the announcement (e.g., user ID or name).'),
  targetAudience: z.array(z.enum(targetAudienceRoleOptions)).min(1).describe('Array of roles the announcement is targeted at. Stored as JSON string in DB usually.'),
  isPublished: z.boolean().describe('Whether the announcement is currently visible to users.'),
  isSticky: z.boolean().describe('Whether the announcement should be pinned or highlighted.'),
  createdAt: z.string().datetime().describe('Timestamp of when the announcement was created. ISO 8601 format.'),
  updatedAt: z.string().datetime().describe('Timestamp of when the announcement was last updated. ISO 8601 format.'),
});
export type Announcement = z.infer<typeof AnnouncementSchema>;

export const CreateAnnouncementInputSchema = AnnouncementSchema.omit({ 
    id: true, 
    author: true, // Will be set by the server/logged-in user context
    createdAt: true, 
    updatedAt: true 
});
export type CreateAnnouncementInput = z.infer<typeof CreateAnnouncementInputSchema>;

export const UpdateAnnouncementInputSchema = AnnouncementSchema.omit({ 
    author: true, // Should not be changed on update by input
    createdAt: true, // Should not be changed on update
    updatedAt: true // Will be set by the server
}).partial(); 
export type UpdateAnnouncementInput = z.infer<typeof UpdateAnnouncementInputSchema>;


// --- In-memory store (commented out or to be removed) ---
/*
let announcementsStore: Announcement[] = [
  // ... initial data ...
];
*/

// Flow for creating an announcement
const createAnnouncementFlow = ai.defineFlow(
  {
    name: 'createAnnouncementFlow',
    inputSchema: CreateAnnouncementInputSchema,
    outputSchema: AnnouncementSchema,
  },
  async (input) => {
    if (!pool) throw new Error('Database not configured.');
    const connection = await getConnection();
    try {
      const now = new Date().toISOString();
      const newId = `ann-${Date.now()}-${Math.random().toString(36).substring(7)}`; // Consider UUIDs for production
      const author = 'Usuario Actual (Backend)'; // TODO: Replace with actual user context

      // TODO: Adapt SQL query to your table structure.
      // targetAudience is an array, often stored as JSON string in SQL.
      const sql = \`
        INSERT INTO announcements (id, title, content, urgency, publicationDate, expirationDate, author, targetAudience, isPublished, isSticky, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      \`;
      const values = [
        newId,
        input.title,
        input.content,
        input.urgency,
        new Date(input.publicationDate).toISOString(),
        input.expirationDate ? new Date(input.expirationDate).toISOString() : null,
        author,
        JSON.stringify(input.targetAudience), // Store as JSON string
        input.isPublished,
        input.isSticky,
        now,
        now,
      ];

      await connection.execute(sql, values);

      const newAnnouncement: Announcement = {
        ...input,
        id: newId,
        author,
        publicationDate: new Date(input.publicationDate).toISOString(),
        expirationDate: input.expirationDate ? new Date(input.expirationDate).toISOString() : null,
        createdAt: now,
        updatedAt: now,
      };
      return newAnnouncement;
    } finally {
      connection.release();
    }
  }
);

export async function createAnnouncement(input: CreateAnnouncementInput): Promise<Announcement> {
  return createAnnouncementFlow(input);
}


// Flow for getting all announcements
const getAnnouncementsFlow = ai.defineFlow(
  {
    name: 'getAnnouncementsFlow',
    inputSchema: z.undefined(), 
    outputSchema: z.array(AnnouncementSchema),
  },
  async () => {
    if (!pool) throw new Error('Database not configured.');
    const connection = await getConnection();
    try {
      // TODO: Adapt SQL query to your table structure.
      const [rows] = await connection.execute('SELECT * FROM announcements ORDER BY createdAt DESC');
      
      // Assuming rows are of type any[] or RowDataPacket[]
      const announcements = (rows as any[]).map(row => ({
        ...row,
        // targetAudience might be stored as JSON string, parse it back.
        targetAudience: typeof row.targetAudience === 'string' ? JSON.parse(row.targetAudience) : row.targetAudience,
        // Ensure boolean values are correct
        isPublished: !!row.isPublished,
        isSticky: !!row.isSticky,
        // Ensure dates are in ISO string format if not already
        publicationDate: new Date(row.publicationDate).toISOString(),
        expirationDate: row.expirationDate ? new Date(row.expirationDate).toISOString() : null,
        createdAt: new Date(row.createdAt).toISOString(),
        updatedAt: new Date(row.updatedAt).toISOString(),
      }));
      return AnnouncementSchema.array().parse(announcements); // Validate against Zod schema
    } finally {
      connection.release();
    }
  }
);

export async function getAnnouncements(): Promise<Announcement[]> {
  return getAnnouncementsFlow();
}

// Flow for updating an announcement
const updateAnnouncementFlow = ai.defineFlow(
  {
    name: 'updateAnnouncementFlow',
    inputSchema: z.object({ 
        id: z.string(), 
        data: UpdateAnnouncementInputSchema 
    }),
    outputSchema: AnnouncementSchema,
  },
  async ({ id, data }) => {
    if (!pool) throw new Error('Database not configured.');
    const connection = await getConnection();
    try {
      const updatedAt = new Date().toISOString();
      
      // TODO: Adapt SQL query to your table structure.
      // Dynamically build the SET part of the query based on fields present in 'data'
      const fieldsToUpdate: string[] = [];
      const values: any[] = [];

      Object.entries(data).forEach(([key, value]) => {
        if (value !== undefined) {
          fieldsToUpdate.push(\`\`\${key}\` = ?\`);
          if (key === 'targetAudience' && Array.isArray(value)) {
            values.push(JSON.stringify(value));
          } else if ((key === 'publicationDate' || key === 'expirationDate') && value !== null) {
            values.push(new Date(value as string).toISOString());
          } 
          else {
            values.push(value);
          }
        }
      });

      if (fieldsToUpdate.length === 0) {
        // No fields to update, fetch and return current state or throw error
        const [currentRows] = await connection.execute('SELECT * FROM announcements WHERE id = ?', [id]);
        if ((currentRows as any[]).length === 0) {
            throw new Error(\`Announcement with id \${id} not found.\`);
        }
        const currentRow = (currentRows as any[])[0];
        return AnnouncementSchema.parse({
            ...currentRow,
            targetAudience: typeof currentRow.targetAudience === 'string' ? JSON.parse(currentRow.targetAudience) : currentRow.targetAudience,
            isPublished: !!currentRow.isPublished,
            isSticky: !!currentRow.isSticky,
            publicationDate: new Date(currentRow.publicationDate).toISOString(),
            expirationDate: currentRow.expirationDate ? new Date(currentRow.expirationDate).toISOString() : null,
            createdAt: new Date(currentRow.createdAt).toISOString(),
            updatedAt: new Date(currentRow.updatedAt).toISOString(),
        });
      }

      fieldsToUpdate.push('`updatedAt` = ?');
      values.push(updatedAt);
      values.push(id); // For the WHERE clause

      const sql = \`UPDATE announcements SET \${fieldsToUpdate.join(', ')} WHERE id = ?\`;
      
      const [result] = await connection.execute(sql, values);
      
      if ((result as mysql.ResultSetHeader).affectedRows === 0) {
        throw new Error(\`Announcement with id \${id} not found or no changes made.\`);
      }

      // Fetch the updated announcement
      const [updatedRows] = await connection.execute('SELECT * FROM announcements WHERE id = ?', [id]);
      const updatedRow = (updatedRows as any[])[0];
       return AnnouncementSchema.parse({
        ...updatedRow,
        targetAudience: typeof updatedRow.targetAudience === 'string' ? JSON.parse(updatedRow.targetAudience) : updatedRow.targetAudience,
        isPublished: !!updatedRow.isPublished,
        isSticky: !!updatedRow.isSticky,
        publicationDate: new Date(updatedRow.publicationDate).toISOString(),
        expirationDate: updatedRow.expirationDate ? new Date(updatedRow.expirationDate).toISOString() : null,
        createdAt: new Date(updatedRow.createdAt).toISOString(),
        updatedAt: new Date(updatedRow.updatedAt).toISOString(),
      });
    } finally {
      connection.release();
    }
  }
);

export async function updateAnnouncement(id: string, data: UpdateAnnouncementInput): Promise<Announcement> {
  return updateAnnouncementFlow({ id, data });
}

// Flow for deleting an announcement
const deleteAnnouncementFlow = ai.defineFlow(
  {
    name: 'deleteAnnouncementFlow',
    inputSchema: z.object({ id: z.string() }),
    outputSchema: z.object({ success: z.boolean(), id: z.string() }),
  },
  async ({ id }) => {
    if (!pool) throw new Error('Database not configured.');
    const connection = await getConnection();
    try {
      // TODO: Adapt SQL query to your table structure.
      const sql = 'DELETE FROM announcements WHERE id = ?';
      const [result] = await connection.execute(sql, [id]);

      if ((result as mysql.ResultSetHeader).affectedRows === 0) {
        throw new Error(\`Announcement with id \${id} not found for deletion.\`);
      }
      return { success: true, id };
    } finally {
      connection.release();
    }
  }
);

export async function deleteAnnouncement(id: string): Promise<{ success: boolean; id: string }> {
  return deleteAnnouncementFlow({ id });
}
