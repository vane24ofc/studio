
'use server';
/**
 * @fileOverview Manages announcements for the platform, interacting with a MySQL database.
 *
 * - createAnnouncement - Creates a new announcement.
 * - getAnnouncements - Retrieves all announcements.
 * - updateAnnouncement - Updates an existing announcement.
 * - deleteAnnouncement - Deletes an announcement.
 * - AnnouncementSchema - Zod schema for an announcement.
 * - CreateAnnouncementInputSchema - Zod schema for creating an announcement.
 * - UpdateAnnouncementInputSchema - Zod schema for updating an announcement.
 * - UrgencyLevelFlow - Type for urgency levels.
 * - TargetAudienceRoleFlow - Type for target audience roles.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit/zod';
import mysql from 'mysql2/promise';
// import type { UserRole as AppUserRole } from '@/types'; // Not currently used, can be added if needed for author based on logged-in user


const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
};

let pool: mysql.Pool | undefined;
try {
  if (dbConfig.host && dbConfig.user && dbConfig.database) {
    pool = mysql.createPool(dbConfig);
    console.log("MySQL connection pool created successfully.");

    // Test query to confirm connection
    pool.query('SELECT 1')
      .then(() => console.log('MySQL connection pool test query successful.'))
      .catch((err) => console.error('MySQL connection pool test query failed:', err));

  } else {
    console.warn("MySQL DB configuration is incomplete. DB_HOST, DB_USER, and DB_NAME must be set in .env. Flows will not connect to DB.");
  }
} catch (error) {
  console.error("Failed to create MySQL connection pool:", error);
}


async function getConnection() {
  if (!pool) {
    console.error('MySQL connection pool is not initialized. Check DB_CONFIG in .env and server logs.');
    throw new Error('MySQL connection pool is not initialized. Check DB_CONFIG in .env and server logs.');
  }
  console.log('Attempting to get connection from pool...');
  const connection = await pool.getConnection();
  console.log('Successfully got connection from pool.');
  return connection;
}


const targetAudienceRoleOptions = ['Administrador', 'Instructor', 'Personal', 'Todos'] as const;
export type TargetAudienceRoleFlow = (typeof targetAudienceRoleOptions)[number];


const UrgencyLevelOptions = ['Normal', 'Importante', 'Urgente', 'Cr√≠tico'] as const;
export type UrgencyLevelFlow = (typeof UrgencyLevelOptions)[number];

export const AnnouncementSchema = z.object({
  id: z.string().describe('Unique identifier for the announcement. Typically auto-generated by the database or a UUID.'),
  title: z.string().min(5).max(100).describe('Title of the announcement.'),
  content: z.string().min(10).describe('Main content of the announcement.'),
  urgency: z.enum(UrgencyLevelOptions).describe('Urgency level of the announcement.'),
  publicationDate: z.string().datetime().describe('Date and time when the announcement is published. ISO 8601 format.'),
  expirationDate: z.string().datetime().nullish().describe('Optional date and time when the announcement expires. ISO 8601 format.'),
  author: z.string().describe('Author of the announcement (e.g., user ID or name).'),
  targetAudience: z.array(z.enum(targetAudienceRoleOptions)).min(1).describe('Array of roles the announcement is targeted at. Stored as JSON string in DB usually.'),
  isPublished: z.boolean().describe('Whether the announcement is currently visible to users.'),
  isSticky: z.boolean().describe('Whether the announcement should be pinned or highlighted.'),
  createdAt: z.string().datetime().describe('Timestamp of when the announcement was created. ISO 8601 format.'),
  updatedAt: z.string().datetime().describe('Timestamp of when the announcement was last updated. ISO 8601 format.'),
});
export type Announcement = z.infer<typeof AnnouncementSchema>;

export const CreateAnnouncementInputSchema = AnnouncementSchema.omit({ 
    id: true, 
    author: true, // Author will be set by backend or passed if available from session
    createdAt: true, 
    updatedAt: true 
});
export type CreateAnnouncementInput = z.infer<typeof CreateAnnouncementInputSchema>;

export const UpdateAnnouncementInputSchema = AnnouncementSchema.omit({ 
    author: true, // Author generally should not be updated this way
    createdAt: true, // createdAt is immutable
    updatedAt: true // updatedAt is set by the backend on update
}).partial(); // .partial() makes all fields optional for updates
export type UpdateAnnouncementInput = z.infer<typeof UpdateAnnouncementInputSchema>;


const createAnnouncementFlow = ai.defineFlow(
  {
    name: 'createAnnouncementFlow',
    inputSchema: CreateAnnouncementInputSchema,
    outputSchema: AnnouncementSchema,
  },
  async (input) => {
    if (!pool) {
      console.error('createAnnouncementFlow: Database not configured.');
      throw new Error('Database not configured.');
    }
    let connection: mysql.PoolConnection | undefined;
    try {
      connection = await getConnection();
      const now = new Date().toISOString();
      const newId = `ann-${Date.now()}-${Math.random().toString(36).substring(7)}`; 
      const author = 'Usuario Actual (Backend)'; // TODO: Replace with actual user context if available

      const sql = `
        INSERT INTO announcements (id, title, content, urgency, publicationDate, expirationDate, author, targetAudience, isPublished, isSticky, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      const values = [
        newId,
        input.title,
        input.content,
        input.urgency,
        new Date(input.publicationDate).toISOString(),
        input.expirationDate ? new Date(input.expirationDate).toISOString() : null,
        author, // Using the backend-defined author for now
        JSON.stringify(input.targetAudience), 
        input.isPublished,
        input.isSticky,
        now,
        now,
      ];

      console.log('Executing SQL for createAnnouncementFlow:', sql.trim().substring(0, 100) + '...');
      await connection.execute(sql, values);
      console.log('SQL execution successful for createAnnouncementFlow. ID:', newId);

      // Construct the full Announcement object to return, matching AnnouncementSchema
      const newAnnouncement: Announcement = {
        ...input,
        id: newId,
        author,
        publicationDate: new Date(input.publicationDate).toISOString(),
        expirationDate: input.expirationDate ? new Date(input.expirationDate).toISOString() : null,
        createdAt: now,
        updatedAt: now,
      };
      return newAnnouncement;
    } catch (error) {
      console.error('Error in createAnnouncementFlow:', error);
      throw error; // Re-throw para que el frontend lo capture
    } finally {
      if (connection) {
        console.log('Releasing connection for createAnnouncementFlow.');
        connection.release();
      }
    }
  }
);

export async function createAnnouncement(input: CreateAnnouncementInput): Promise<Announcement> {
  return createAnnouncementFlow(input);
}


const getAnnouncementsFlow = ai.defineFlow(
  {
    name: 'getAnnouncementsFlow',
    inputSchema: z.undefined(), // No input for getting all announcements
    outputSchema: z.array(AnnouncementSchema),
  },
  async () => {
    if (!pool) {
      console.error('getAnnouncementsFlow: Database not configured.');
      throw new Error('Database not configured.');
    }
    let connection: mysql.PoolConnection | undefined;
    try {
      connection = await getConnection();
      const sql = 'SELECT * FROM announcements ORDER BY createdAt DESC';
      console.log('Executing SQL for getAnnouncementsFlow:', sql);
      const [rows] = await connection.execute(sql);
      console.log('SQL execution successful for getAnnouncementsFlow. Rows found:', (rows as any[]).length);
      
      // Map rows to match AnnouncementSchema, ensuring correct types (JSON parse, boolean conversion)
      const announcements = (rows as any[]).map(row => ({
        ...row,
        targetAudience: typeof row.targetAudience === 'string' ? JSON.parse(row.targetAudience) : row.targetAudience,
        isPublished: !!row.isPublished, // Convert TINYINT(1) or similar to boolean
        isSticky: !!row.isSticky,       // Convert TINYINT(1) or similar to boolean
        publicationDate: new Date(row.publicationDate).toISOString(),
        expirationDate: row.expirationDate ? new Date(row.expirationDate).toISOString() : null,
        createdAt: new Date(row.createdAt).toISOString(),
        updatedAt: new Date(row.updatedAt).toISOString(),
      }));
      return AnnouncementSchema.array().parse(announcements); // Validate against the schema before returning
    } catch (error) {
      console.error('Error in getAnnouncementsFlow:', error);
      // If the error is because the table does not exist (ER_NO_SUCH_TABLE), return an empty array.
      if ((error as any).code === 'ER_NO_SUCH_TABLE') {
        console.warn('Table "announcements" does not exist. Returning empty array for getAnnouncementsFlow.');
        return [];
      }
      throw error; // Re-throw para otros errores
    } finally {
      if (connection) {
        console.log('Releasing connection for getAnnouncementsFlow.');
        connection.release();
      }
    }
  }
);

export async function getAnnouncements(): Promise<Announcement[]> {
  return getAnnouncementsFlow();
}

const updateAnnouncementFlow = ai.defineFlow(
  {
    name: 'updateAnnouncementFlow',
    inputSchema: z.object({ 
        id: z.string(), 
        data: UpdateAnnouncementInputSchema 
    }),
    outputSchema: AnnouncementSchema,
  },
  async ({ id, data }) => {
    if (!pool) {
      console.error('updateAnnouncementFlow: Database not configured.');
      throw new Error('Database not configured.');
    }
    let connection: mysql.PoolConnection | undefined;
    try {
      connection = await getConnection();
      const updatedAt = new Date().toISOString();
      
      const fieldsToUpdate: string[] = [];
      const values: any[] = [];

      Object.entries(data).forEach(([key, value]) => {
        if (value !== undefined) { // Only include fields that are actually being updated
          fieldsToUpdate.push(`\`${key}\` = ?`);
          if (key === 'targetAudience' && Array.isArray(value)) {
            values.push(JSON.stringify(value));
          } else if ((key === 'publicationDate' || key === 'expirationDate') && value !== null) {
            values.push(new Date(value as string).toISOString());
          } 
          // Handle boolean conversion explicitly if MySQL driver doesn't do it automatically
          // else if (typeof value === 'boolean' && (key === 'isPublished' || key === 'isSticky')) {
          //   values.push(value ? 1 : 0);
          // } 
          else {
            values.push(value);
          }
        }
      });

      if (fieldsToUpdate.length === 0) {
        // No actual fields to update, just return the current announcement
        console.log('updateAnnouncementFlow: No fields to update for id:', id);
        const [currentRows] = await connection.execute('SELECT * FROM announcements WHERE id = ?', [id]);
        if ((currentRows as any[]).length === 0) {
            console.error(`updateAnnouncementFlow: Announcement with id ${id} not found when no fields to update.`);
            throw new Error(`Announcement with id ${id} not found.`);
        }
        const currentRow = (currentRows as any[])[0];
        return AnnouncementSchema.parse({
            ...currentRow,
            targetAudience: typeof currentRow.targetAudience === 'string' ? JSON.parse(currentRow.targetAudience) : currentRow.targetAudience,
            isPublished: !!currentRow.isPublished,
            isSticky: !!currentRow.isSticky,
            publicationDate: new Date(currentRow.publicationDate).toISOString(),
            expirationDate: currentRow.expirationDate ? new Date(currentRow.expirationDate).toISOString() : null,
            createdAt: new Date(currentRow.createdAt).toISOString(),
            updatedAt: new Date(currentRow.updatedAt).toISOString(),
        });
      }

      fieldsToUpdate.push('`updatedAt` = ?');
      values.push(updatedAt);
      values.push(id); // For the WHERE id = ? clause

      const sql = `UPDATE announcements SET ${fieldsToUpdate.join(', ')} WHERE id = ?`;
      console.log('Executing SQL for updateAnnouncementFlow:', sql.trim().substring(0, 100) + '...');
      const [result] = await connection.execute(sql, values);
      console.log('SQL execution result for updateAnnouncementFlow:', result);
      
      if ((result as mysql.ResultSetHeader).affectedRows === 0) {
        console.error(`updateAnnouncementFlow: Announcement with id ${id} not found or no changes made.`);
        throw new Error(`Announcement with id ${id} not found or no changes made.`);
      }

      // Fetch the updated announcement to return
      const [updatedRows] = await connection.execute('SELECT * FROM announcements WHERE id = ?', [id]);
      const updatedRow = (updatedRows as any[])[0];
       return AnnouncementSchema.parse({
        ...updatedRow,
        targetAudience: typeof updatedRow.targetAudience === 'string' ? JSON.parse(updatedRow.targetAudience) : updatedRow.targetAudience,
        isPublished: !!updatedRow.isPublished,
        isSticky: !!updatedRow.isSticky,
        publicationDate: new Date(updatedRow.publicationDate).toISOString(),
        expirationDate: updatedRow.expirationDate ? new Date(updatedRow.expirationDate).toISOString() : null,
        createdAt: new Date(updatedRow.createdAt).toISOString(),
        updatedAt: new Date(updatedRow.updatedAt).toISOString(),
      });
    } catch (error) {
      console.error('Error in updateAnnouncementFlow:', error);
      throw error;
    } finally {
      if (connection) {
        console.log('Releasing connection for updateAnnouncementFlow.');
        connection.release();
      }
    }
  }
);

export async function updateAnnouncement(id: string, data: UpdateAnnouncementInput): Promise<Announcement> {
  // Ensure 'id' is not part of 'data' as it's passed separately
  const dataWithoutId = { ...data };
  delete (dataWithoutId as any).id;
  return updateAnnouncementFlow({ id, data: dataWithoutId });
}

const deleteAnnouncementFlow = ai.defineFlow(
  {
    name: 'deleteAnnouncementFlow',
    inputSchema: z.object({ id: z.string() }),
    outputSchema: z.object({ success: z.boolean(), id: z.string() }),
  },
  async ({ id }) => {
    if (!pool) {
      console.error('deleteAnnouncementFlow: Database not configured.');
      throw new Error('Database not configured.');
    }
    let connection: mysql.PoolConnection | undefined;
    try {
      connection = await getConnection();
      const sql = 'DELETE FROM announcements WHERE id = ?';
      console.log('Executing SQL for deleteAnnouncementFlow:', sql);
      const [result] = await connection.execute(sql, [id]);
      console.log('SQL execution result for deleteAnnouncementFlow:', result);

      if ((result as mysql.ResultSetHeader).affectedRows === 0) {
        console.error(`deleteAnnouncementFlow: Announcement with id ${id} not found for deletion.`);
        throw new Error(`Announcement with id ${id} not found for deletion.`);
      }
      return { success: true, id };
    } catch (error) {
      console.error('Error in deleteAnnouncementFlow:', error);
      throw error;
    } finally {
      if (connection) {
        console.log('Releasing connection for deleteAnnouncementFlow.');
        connection.release();
      }
    }
  }
);

export async function deleteAnnouncement(id: string): Promise<{ success: boolean; id: string }> {
  return deleteAnnouncementFlow({ id });
}

// Ensure all necessary types and functions are explicitly exported
// Schemas and Types are already exported above.
// Wrapper functions are also exported.
    

    